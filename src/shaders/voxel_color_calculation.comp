#version 460

#include "types.glsl"
#include "voxel_descriptors.glsl"
#include "global_descriptor_set.glsl"


struct CalculatedLightPower {
    vec3 diffuse_strength;
    vec3 specular_strength;
};

CalculatedLightPower calculate_light_power(
    vec3 camera_position,
    vec3 voxel_position,
    vec3 voxel_normal,
    PointLight light,
    float specular_power
) {
    vec3 to_light_vector = light.position.xyz - voxel_position;
    float to_light_distance = length(to_light_vector);
    to_light_vector /= to_light_distance;

    if (to_light_distance > 256.0 || light.color_and_power.w < 0.25)
    {
        return CalculatedLightPower(vec3(0.0), vec3(0.0));
    }

    vec3 view_vector = normalize(camera_position - voxel_position);
    vec3 reflect_vector = 2.0 * dot(to_light_vector, voxel_normal) * voxel_normal - to_light_vector;

    float attenuation = 1.0 / (
        light.falloffs.x +
        light.falloffs.y * to_light_distance +
        light.falloffs.z * to_light_distance * to_light_distance +
        light.falloffs.w * to_light_distance * to_light_distance * to_light_distance);

    vec3 diffuse_strength = max(dot(voxel_normal, to_light_vector), 0.0) * light.color_and_power.rgb * light.color_and_power.w * attenuation;
    vec3 specular_strength = pow(max(dot(reflect_vector, view_vector), 0.0), specular_power) * light.color_and_power.rgb * light.color_and_power.w * attenuation;

    return CalculatedLightPower(diffuse_strength, specular_strength);
}

#define DrivingAxis u32
const u32 DrivingAxis_X = 0;
const u32 DrivingAxis_Y = 1;
const u32 DrivingAxis_Z = 2;

i32 moduloEuclideani32(i32 lhs, i32 rhs)
{
    if (lhs < 0)
    {
        // Offset lhs to ensure positive remainder
        lhs += (-lhs / rhs + 1) * rhs; 
    }

    const i32 remainder = lhs % rhs;
    if (remainder < 0)
    {
        return rhs > 0 ? remainder + rhs : remainder - rhs;
    }
    return remainder;
}

i32 divideEuclideani32(i32 lhs, i32 rhs)
{
    int quotient = lhs / rhs;
    int remainder = lhs % rhs;

    // Adjust quotient for Euclidean behavior
    if (remainder != 0 && ((rhs < 0) != (lhs < 0))) {
        quotient -= 1;
    }

    return quotient;
}

struct GetIdxAndBitResult
{
    u32 idx;
    u32 bit;
};

GetIdxAndBitResult getIdxAndBit(ivec3 p)
{
    const u32 linearIndex = 
        p.x + p.z * 8
        + p.y * 8 * 8;

    return GetIdxAndBitResult(linearIndex / 32, linearIndex % 32);
}

bool isGlobalPositionOccupied(ivec3 pos)
{
    // TODO: this isnt the right coordinate
    ivec3 globalChunkCoordinate = ivec3(
        divideEuclideani32(pos.x, 64),
        divideEuclideani32(pos.y, 64),
        divideEuclideani32(pos.z, 64)
    );

    ivec3 positionWithinChunk = ivec3(
        moduloEuclideani32(pos.x, 64),
        moduloEuclideani32(pos.y, 64),
        moduloEuclideani32(pos.z, 64)
    );

    u16 chunk = in_global_chunks.chunk[globalChunkCoordinate.x + 128][globalChunkCoordinate.y + 128][globalChunkCoordinate.z + 128];

    if (chunk == u16(-1))
    {
        return false;
    }

    ivec3 brickCoordinate = positionWithinChunk / 8;
    ivec3 brickPosition = positionWithinChunk % 8;

    MaybeBrickPointer maybePtr = in_brick_maps.map[chunk].data[brickCoordinate.x][brickCoordinate.y][brickCoordinate.z];

    if (maybePtr.pointer == ~0u)
    {
        return false;
    }

    GetIdxAndBitResult r = getIdxAndBit(brickPosition);

    if ((in_opacity_bricks.brick[maybePtr.pointer].data[r.idx] & (1u << r.bit)) == 0)
    {
        return false;
    }
    else
    {
        return true;
    }

    
}

bool trace_ray_shitty_perfect(const vec3 origin, const vec3 dir, const float max_dist)
{    
    if (isGlobalPositionOccupied(ivec3(floor(origin)))) return true;

    float t = 0.0;

    // Axis distance to nearest cell (with a small bias).
    const vec3 dist =  fract(-origin * sign(dir)) + 1e-4;
    // Raytraced distance to each axis.
    const vec3 leng = dist / abs(dir);
    // Nearest axis' raytrace distance (as a vec3).
    const float closestAxis = min(leng.x, min(leng.y, leng.z));

    for(int i = 0; i < 256; i++)
    {
        t += closestAxis;

        if (t > max_dist)
        {
            return false;
        }
        
        if (isGlobalPositionOccupied(ivec3(floor(origin + dir * t)))) return true;
    } 
    
    return false;
}

bool traceDDARay(vec3 start, vec3 end)
{
    if (length(end - start) > 256.0)
    {
        return false;
    }
    return trace_ray_shitty_perfect(start, normalize(end - start), length(end - start));

}
  

vec3 exp_strength_falloff(vec3 strengths)
{
    return 1.0 - exp2(-0.25 * strengths);
}

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const u32 global_invocation_index = gl_GlobalInvocationID.x;

    if (global_invocation_index < in_global_voxel_data.number_of_visible_faces)
    {
        const u32 this_face_data = in_visible_face_data.data[global_invocation_index].data;
        
        const u32 brick_pointer = bitfieldExtract(this_face_data, 0, 20);
        const u32 face_number   = bitfieldExtract(this_face_data, 20, 9);
        const u32 normal        = bitfieldExtract(this_face_data, 29, 3);

        const uvec3 brick_local_position = uvec3(
            face_number % 8,
            (face_number % 64) / 8,
            face_number / 64
        );

        const u32 parent_chunk = bitfieldExtract(in_brick_parent_info.info[brick_pointer].data, 0, 16);
        const u32 brick_parent_number = bitfieldExtract(in_brick_parent_info.info[brick_pointer].data, 23, 9);

        const uvec3 brick_coordinate = uvec3(
            brick_parent_number % 8,
            (brick_parent_number % 64) / 8,
            brick_parent_number / 64
        );

        const uvec3 chunk_local_position = brick_coordinate * 8 + brick_local_position;

        const Voxel this_voxel = in_material_bricks.brick[brick_pointer]
            .data[brick_local_position.x][brick_local_position.y][brick_local_position.z];

        const VoxelMaterial this_material = in_voxel_materials.material[this_voxel.data];

        // TODO: shouldn't be 0.5 the normal should be removed from this
        const ivec3 voxel_corner_pos_world = in_chunk_data.data[parent_chunk].position.xyz + ivec3(chunk_local_position);
        const vec3 sample_positon_world = vec3(voxel_corner_pos_world) + 0.5 + unpackNormalId(normal);

        vec3 sum_diffuse = vec3(0.0);
        vec3 sum_specular = vec3(0.0);

        for (int i = 0; i < in_global_voxel_data.number_of_lights; ++i)
        {
            const bool isFaceInShadow = traceDDARay(
                sample_positon_world, 
                in_point_lights.lights[i].position.xyz
            );

            if (!isFaceInShadow)
            {
                CalculatedLightPower power = calculate_light_power(
                    in_global_info.camera_position.xyz,
                    sample_positon_world,
                    unpackNormalId(normal), 
                    in_point_lights.lights[i],
                    this_material.specular
                );

                sum_diffuse += power.diffuse_strength;
                // #warning no specular
                sum_specular += power.specular_strength;
            }
        }

        vec3 realColor = clamp(
            exp_strength_falloff(sum_diffuse) * this_material.diffuse_color.xyz +
            exp_strength_falloff(sum_specular) * this_material.specular_color.xyz,
            0.0,
            1.0
        );


        if (!isGlobalPositionOccupied(voxel_corner_pos_world))
        {
            in_visible_face_data.data[global_invocation_index].color = vec3(1.0); 
            return;
        }

        in_visible_face_data.data[global_invocation_index].color = realColor;           
    }
}