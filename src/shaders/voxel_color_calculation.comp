#version 460

#include "types.glsl"
#include "voxel_descriptors.glsl"
#include "global_descriptor_set.glsl"


struct CalculatedLightPower {
    vec3 diffuse_strength;
    vec3 specular_strength;
};

CalculatedLightPower calculate_light_power(
    vec3 camera_position,
    vec3 voxel_position,
    vec3 voxel_normal,
    PointLight light,
    float specular_power
) {
    vec3 to_light_vector = light.position.xyz - voxel_position;
    float to_light_distance = length(to_light_vector);
    to_light_vector /= to_light_distance;

    vec3 view_vector = normalize(camera_position - voxel_position);
    vec3 reflect_vector = 2.0 * dot(to_light_vector, voxel_normal) * voxel_normal - to_light_vector;

    float attenuation = 1.0 / (
        light.falloffs.x +
        light.falloffs.y * to_light_distance +
        light.falloffs.z * to_light_distance * to_light_distance +
        light.falloffs.w * to_light_distance * to_light_distance * to_light_distance);
    
    // dot(voxel_normal, to_light_vector) * 0.5 + 0.5 half lambert
    vec3 diffuse_strength = max(dot(voxel_normal, to_light_vector), 0.0) * light.color_and_power.rgb * light.color_and_power.w * attenuation;
    vec3 specular_strength = pow(max(dot(reflect_vector, view_vector), 0.0), specular_power) * light.color_and_power.rgb * light.color_and_power.w * attenuation;

    return CalculatedLightPower(diffuse_strength, specular_strength);
}

// #define DrivingAxis u32
// const u32 DrivingAxis_X = 0;
// const u32 DrivingAxis_Y = 1;
// const u32 DrivingAxis_Z = 2;

i32 moduloEuclideani32(i32 lhs, i32 rhs)
{
    if (lhs < 0)
    {
        // Offset lhs to ensure positive remainder
        lhs += (-lhs / rhs + 1) * rhs; 
    }

    const i32 remainder = lhs % rhs;
    if (remainder < 0)
    {
        return rhs > 0 ? remainder + rhs : remainder - rhs;
    }
    return remainder;
}

i32 divideEuclideani32(i32 lhs, i32 rhs)
{
    int quotient = lhs / rhs;
    int remainder = lhs % rhs;

    // Adjust quotient for Euclidean behavior
    if (remainder != 0 && ((rhs < 0) != (lhs < 0))) {
        quotient -= 1;
    }

    return quotient;
}

struct GetIdxAndBitResult
{
    u32 idx;
    u32 bit;
};

bool err = false;

GetIdxAndBitResult getIdxAndBit(ivec3 p)
{
    const u32 linearIndex = 
        p.x + p.z * 8
        + p.y * 8 * 8;

    if (linearIndex >= 512 || any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, ivec3(8))))
    {
        err = true;
    }

    return GetIdxAndBitResult(linearIndex / 32, linearIndex % 32);
}

bool OpactityBrick_read(u32 ptr, ivec3 pos)
{
    GetIdxAndBitResult r = getIdxAndBit(pos);

    if ((in_opacity_bricks.brick[ptr].data[r.idx] & (1u << r.bit)) == 0)
    {
        return false;
    }
    else
    {
        return true;
    }
}

u32 getBrickOfWorldPosition(ivec3 pos)
{
    // TODO: this isnt the right coordinate
    ivec3 globalChunkCoordinate = ivec3(
        divideEuclideani32(pos.x, 64),
        divideEuclideani32(pos.y, 64),
        divideEuclideani32(pos.z, 64)
    );

    ivec3 positionWithinChunk = ivec3(
        moduloEuclideani32(pos.x, 64),
        moduloEuclideani32(pos.y, 64),
        moduloEuclideani32(pos.z, 64)
    );

    u16 chunk = in_global_chunks.chunk[globalChunkCoordinate.x + 128][globalChunkCoordinate.y + 128][globalChunkCoordinate.z + 128];

    if (chunk == u16(-1))
    {
        return ~0u;
    }

    ivec3 brickCoordinate = positionWithinChunk / 8;
    ivec3 brickPosition = positionWithinChunk % 8;

    MaybeBrickPointer maybePtr = in_brick_maps.map[chunk].data[brickCoordinate.x][brickCoordinate.y][brickCoordinate.z];

    return maybePtr.pointer;
}

bool isGlobalPositionOccupied(ivec3 pos)
{
    // TODO: this isnt the right coordinate
    ivec3 globalChunkCoordinate = ivec3(
        divideEuclideani32(pos.x, 64),
        divideEuclideani32(pos.y, 64),
        divideEuclideani32(pos.z, 64)
    );

    ivec3 positionWithinChunk = ivec3(
        moduloEuclideani32(pos.x, 64),
        moduloEuclideani32(pos.y, 64),
        moduloEuclideani32(pos.z, 64)
    );

    u16 chunk = in_global_chunks.chunk[globalChunkCoordinate.x + 128][globalChunkCoordinate.y + 128][globalChunkCoordinate.z + 128];

    if (chunk == u16(-1))
    {
        return false;
    }

    ivec3 brickCoordinate = positionWithinChunk / 8;
    ivec3 brickPosition = positionWithinChunk % 8;

    MaybeBrickPointer maybePtr = in_brick_maps.map[chunk].data[brickCoordinate.x][brickCoordinate.y][brickCoordinate.z];

    if (maybePtr.pointer == ~0u)
    {
        return false;
    }

    GetIdxAndBitResult r = getIdxAndBit(brickPosition);

    if ((in_opacity_bricks.brick[maybePtr.pointer].data[r.idx] & (1u << r.bit)) == 0)
    {
        return false;
    }
    else
    {
        return true;
    }

    
}


vec3 stepMask(vec3 sideDist) {
    bvec3 mask;
    bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);
    bvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);
    mask.z = b1.z && b2.z;
    mask.x = b1.x && b2.x;
    mask.y = b1.y && b2.y;
    if(!any(mask)) // Thank you Spalmer
        mask.z = true;
        
    return vec3(mask);
}

bool traceBlock(u32 brick, vec3 rayPos, vec3 rayDir, vec3 iMask, float max_dist) {
    rayPos = clamp(rayPos, vec3(0.0001), vec3(7.9999));
    vec3 mapPos = floor(rayPos);
    vec3 raySign = sign(rayDir);
    vec3 deltaDist = 1.0/rayDir;
    vec3 sideDist = ((mapPos - rayPos) + 0.5 + raySign * 0.5) * deltaDist;
    vec3 mask = iMask;
    
    while (
        all(lessThanEqual(mapPos, vec3(7.0))) &&
        all(greaterThanEqual(mapPos, vec3(0.0))) &&
        length(mapPos - rayPos) < max_dist)
    {
        if (OpactityBrick_read(brick, ivec3(mapPos)))
            return true;
            
       mask      = stepMask(sideDist);
       mapPos   += mask * raySign;
       sideDist += mask * raySign * deltaDist;
    }
    
    return false;
}

bool traceWorld(vec3 rayPos, vec3 rayDir, float max_dist) {    
    vec3 mapPos = floor(rayPos);
    vec3 raySign = sign(rayDir);
    vec3 deltaDist = 1.0/rayDir;
    vec3 sideDist = ((mapPos-rayPos) + 0.5 + raySign * 0.5) * deltaDist;
    vec3 mask = stepMask(sideDist);
    
    for (int i = 0; i < 256 && length(mapPos - rayPos) < max_dist; i++) {
        u32 brick = getBrickOfWorldPosition(ivec3(mapPos * 8.0));
        if (brick != ~0u) {
           vec3 mini = ((mapPos-rayPos) + 0.5 - 0.5*vec3(raySign))*deltaDist;
           float d = max (mini.x, max (mini.y, mini.z));
           vec3 intersect = rayPos + rayDir*d;
           vec3 uv3d = intersect - mapPos;

           if (mapPos == floor(rayPos)) // Handle edge case where camera origin is inside of block
               uv3d = rayPos - mapPos;

           bool hit = traceBlock(brick, uv3d * 8.0, rayDir, mask, (max_dist - length(mapPos - rayPos)) * 8.0 );

           if (hit) 
                return true;
       }
       
       mask      = stepMask(sideDist);
       mapPos   += mask * raySign;
       sideDist += mask * raySign * deltaDist;
    }
    
    return false;
}


//The raycasting code is somewhat based around a 2D raycasting toutorial found here: 
//http://lodev.org/cgtutor/raycasting.html

// const bool USE_BRANCHLESS_DDA = false;
// const int MAX_RAY_STEPS = 512;

// float sdSphere(vec3 p, float d) { return length(p) - d; } 

// float sdBox( vec3 p, vec3 b )
// {
//   vec3 d = abs(p) - b;
//   return min(max(d.x,max(d.y,d.z)),0.0) +
//          length(max(d,0.0));
// }
	
// bool getVoxel(ivec3 c) {
// 	vec3 p = vec3(c) + vec3(0.5);
// 	float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));
// 	return d < 0.0;
// }

// vec2 rotate2d(vec2 v, float a) {
// 	float sinA = sin(a);
// 	float cosA = cos(a);
// 	return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);	
// }
// // Function signature for ray tracing   
// bool traceRealDDARay(vec3 rayPos, vec3 rayDir, float max_dist) {
//     ivec3 mapPos = ivec3(floor(rayPos));
//     vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
//     ivec3 rayStep = ivec3(sign(rayDir));
//     vec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
//     bvec3 mask;

//     for (int i = 0; i < MAX_RAY_STEPS && length(vec3(mapPos) - rayPos) < max_dist; i++) {
//         if (isGlobalPositionOccupied(mapPos)) return true;
        
//         if (USE_BRANCHLESS_DDA) {
//             mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
//             sideDist += vec3(mask) * deltaDist;
//             mapPos += ivec3(vec3(mask)) * rayStep;
//         } else {
//             if (sideDist.x < sideDist.y) {
//                 if (sideDist.x < sideDist.z) {
//                     sideDist.x += deltaDist.x;
//                     mapPos.x += rayStep.x;
//                     mask = bvec3(true, false, false);
//                 } else {
//                     sideDist.z += deltaDist.z;
//                     mapPos.z += rayStep.z;
//                     mask = bvec3(false, false, true);
//                 }
//             } else {
//                 if (sideDist.y < sideDist.z) {
//                     sideDist.y += deltaDist.y;
//                     mapPos.y += rayStep.y;
//                     mask = bvec3(false, true, false);
//                 } else {
//                     sideDist.z += deltaDist.z;
//                     mapPos.z += rayStep.z;
//                     mask = bvec3(false, false, true);
//                 }
//             }
//         }
//     }

//     return false;
// }

// void mainImage(out vec4 fragColor, in vec2 fragCoord) {
//     vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;
//     vec3 cameraDir = vec3(0.0, 0.0, 0.8);
//     vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);
//     vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;
//     vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;
//     vec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);
    
//     rayPos.xz = rotate2d(rayPos.xz, iTime);
//     rayDir.xz = rotate2d(rayDir.xz, iTime);
    
//     ivec3 mask = traceRay(rayPos, rayDir);

//     vec3 color = sin(vec3(mask)) * 0.5 + 0.5;
    
//     fragColor.rgb = color;
// }


// bool trace_ray_shitty_perfect(const vec3 origin, const vec3 dir, const float max_dist)
// {    
//     if (isGlobalPositionOccupied(ivec3(floor(origin)))) return true;

//     float t = 0.0;

//     // Axis distance to nearest cell (with a small bias).
//     const vec3 dist =  fract(-origin * sign(dir)) + 1e-4;
//     // Raytraced distance to each axis.
//     const vec3 leng = dist / abs(dir);
//     // Nearest axis' raytrace distance (as a vec3).
//     const float closestAxis = min(leng.x, min(leng.y, leng.z));

//     for(int i = 0; i < 256; i++)
//     {
//         t += closestAxis;

//         if (t > max_dist)
//         {
//             return false;
//         }
        
//         if (isGlobalPositionOccupied(ivec3(floor(origin + dir * t)))) return true;
//     } 
    
//     return false;
// }

bool traceDDARay(vec3 start, vec3 end)
{
    // if (length(end - start) > 256)
    // {
    //     return true;
    // }
    return traceWorld(start / 8.0, normalize(end - start), length(end - start) / 8.0);
}
  

vec3 exp_strength_falloff(vec3 strengths)
{
    return 1.0 - exp2(-0.25 * strengths);
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const u32 global_invocation_index = gl_GlobalInvocationID.x;

    if (global_invocation_index < in_global_voxel_data.number_of_visible_faces)
    {
        const u32 this_face_data = in_visible_face_data.data[global_invocation_index].data;
        
        const u32 brick_pointer = bitfieldExtract(this_face_data, 0, 20);
        const u32 face_number   = bitfieldExtract(this_face_data, 20, 9);
        const u32 normal        = bitfieldExtract(this_face_data, 29, 3);

        const uvec3 brick_local_position = uvec3(
            face_number % 8,
            (face_number % 64) / 8,
            face_number / 64
        );

        const u32 parent_chunk = bitfieldExtract(in_brick_parent_info.info[brick_pointer].data, 0, 16);
        const u32 brick_parent_number = bitfieldExtract(in_brick_parent_info.info[brick_pointer].data, 23, 9);

        const uvec3 brick_coordinate = uvec3(
            brick_parent_number % 8,
            (brick_parent_number % 64) / 8,
            brick_parent_number / 64
        );

        const uvec3 chunk_local_position = brick_coordinate * 8 + brick_local_position;

        const Voxel this_voxel = in_material_bricks.brick[brick_pointer]
            .data[brick_local_position.x][brick_local_position.y][brick_local_position.z];

        const VoxelMaterial this_material = in_voxel_materials.material[this_voxel.data];

        // TODO: shouldn't be 0.5 the normal should be removed from this
        const ivec3 voxel_corner_pos_world = in_chunk_data.data[parent_chunk].position.xyz + ivec3(chunk_local_position);
        const vec3 sample_positon_world = vec3(voxel_corner_pos_world) + 0.5 + unpackNormalId(normal);

        vec3 sum_diffuse = vec3(0.0);
        vec3 sum_specular = vec3(0.0);

        for (int i = 0; i < in_global_voxel_data.number_of_lights; ++i)
        {
            const bool isFaceInShadow = traceDDARay(
                sample_positon_world, 
                in_point_lights.lights[i].position.xyz
            );


            if (!isFaceInShadow)
            {
                CalculatedLightPower power = calculate_light_power(
                    in_global_info.camera_position.xyz,
                    sample_positon_world,
                    unpackNormalId(normal), 
                    in_point_lights.lights[i],
                    this_material.specular
                );

                sum_diffuse += power.diffuse_strength;
                // #warning no specular
                sum_specular += power.specular_strength;
            }
        }

        sum_diffuse = clamp(sum_diffuse, 0.07, 1024.0);

        if (err)
        {
            sum_diffuse = vec3(0.0);
        }

        vec3 realColor = clamp(
            exp_strength_falloff(sum_diffuse) * this_material.diffuse_color.xyz +
            exp_strength_falloff(sum_specular) * this_material.specular_color.xyz,
            0.0,
            1.0
        );


        if (!isGlobalPositionOccupied(voxel_corner_pos_world))
        {
            in_visible_face_data.data[global_invocation_index].color = vec3(1.0); 
            return;
        }

        in_visible_face_data.data[global_invocation_index].color = realColor;           
    }
}